{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport * as React from \"rehackt\";\nimport { mergeDeepArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport equal from \"@wry/equality\";\nexport function useFragment(options) {\n  return wrapHook(\"useFragment\",\n  // eslint-disable-next-line react-compiler/react-compiler\n  useFragment_, useApolloClient(options.client))(options);\n}\nfunction useFragment_(options) {\n  var client = useApolloClient(options.client);\n  var cache = client.cache;\n  var from = options.from,\n    rest = __rest(options, [\"from\"]);\n  // We calculate the cache id seperately from `stableOptions` because we don't\n  // want changes to non key fields in the `from` property to affect\n  // `stableOptions` and retrigger our subscription. If the cache identifier\n  // stays the same between renders, we want to reuse the existing subscription.\n  var id = React.useMemo(function () {\n    return typeof from === \"string\" ? from : from === null ? null : cache.identify(from);\n  }, [cache, from]);\n  var stableOptions = useDeepMemo(function () {\n    return __assign(__assign({}, rest), {\n      from: id\n    });\n  }, [rest, id]);\n  // Since .next is async, we need to make sure that we\n  // get the correct diff on the next render given new diffOptions\n  var diff = React.useMemo(function () {\n    var fragment = stableOptions.fragment,\n      fragmentName = stableOptions.fragmentName,\n      from = stableOptions.from,\n      _a = stableOptions.optimistic,\n      optimistic = _a === void 0 ? true : _a;\n    if (from === null) {\n      return {\n        result: diffToResult({\n          result: {},\n          complete: false\n        })\n      };\n    }\n    var cache = client.cache;\n    var diff = cache.diff(__assign(__assign({}, stableOptions), {\n      returnPartialData: true,\n      id: from,\n      query: cache[\"getFragmentDoc\"](fragment, fragmentName),\n      optimistic: optimistic\n    }));\n    return {\n      result: diffToResult(__assign(__assign({}, diff), {\n        result: client[\"queryManager\"].maskFragment({\n          fragment: fragment,\n          fragmentName: fragmentName,\n          data: diff.result\n        })\n      }))\n    };\n  }, [client, stableOptions]);\n  // Used for both getSnapshot and getServerSnapshot\n  var getSnapshot = React.useCallback(function () {\n    return diff.result;\n  }, [diff]);\n  return useSyncExternalStore(React.useCallback(function (forceUpdate) {\n    var lastTimeout = 0;\n    var subscription = stableOptions.from === null ? null : client.watchFragment(stableOptions).subscribe({\n      next: function (result) {\n        // Since `next` is called async by zen-observable, we want to avoid\n        // unnecessarily rerendering this hook for the initial result\n        // emitted from watchFragment which should be equal to\n        // `diff.result`.\n        if (equal(result, diff.result)) return;\n        diff.result = result;\n        // If we get another update before we've re-rendered, bail out of\n        // the update and try again. This ensures that the relative timing\n        // between useQuery and useFragment stays roughly the same as\n        // fixed in https://github.com/apollographql/apollo-client/pull/11083\n        clearTimeout(lastTimeout);\n        lastTimeout = setTimeout(forceUpdate);\n      }\n    });\n    return function () {\n      subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();\n      clearTimeout(lastTimeout);\n    };\n  }, [client, stableOptions, diff]), getSnapshot, getSnapshot);\n}\nfunction diffToResult(diff) {\n  var result = {\n    data: diff.result,\n    complete: !!diff.complete\n  };\n  if (diff.missing) {\n    result.missing = mergeDeepArray(diff.missing.map(function (error) {\n      return error.missing;\n    }));\n  }\n  return result;\n}","map":{"version":3,"names":["__assign","__rest","React","mergeDeepArray","useApolloClient","useSyncExternalStore","useDeepMemo","wrapHook","equal","useFragment","options","useFragment_","client","cache","from","rest","id","useMemo","identify","stableOptions","diff","fragment","fragmentName","_a","optimistic","result","diffToResult","complete","returnPartialData","query","maskFragment","data","getSnapshot","useCallback","forceUpdate","lastTimeout","subscription","watchFragment","subscribe","next","clearTimeout","setTimeout","unsubscribe","missing","map","error"],"sources":["C:/Users/admin/3D Objects/Frontend/my-app/node_modules/@apollo/client/react/hooks/useFragment.js"],"sourcesContent":["import { __assign, __rest } from \"tslib\";\nimport * as React from \"rehackt\";\nimport { mergeDeepArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport equal from \"@wry/equality\";\nexport function useFragment(options) {\n    return wrapHook(\"useFragment\", \n    // eslint-disable-next-line react-compiler/react-compiler\n    useFragment_, useApolloClient(options.client))(options);\n}\nfunction useFragment_(options) {\n    var client = useApolloClient(options.client);\n    var cache = client.cache;\n    var from = options.from, rest = __rest(options, [\"from\"]);\n    // We calculate the cache id seperately from `stableOptions` because we don't\n    // want changes to non key fields in the `from` property to affect\n    // `stableOptions` and retrigger our subscription. If the cache identifier\n    // stays the same between renders, we want to reuse the existing subscription.\n    var id = React.useMemo(function () {\n        return typeof from === \"string\" ? from\n            : from === null ? null\n                : cache.identify(from);\n    }, [cache, from]);\n    var stableOptions = useDeepMemo(function () { return (__assign(__assign({}, rest), { from: id })); }, [rest, id]);\n    // Since .next is async, we need to make sure that we\n    // get the correct diff on the next render given new diffOptions\n    var diff = React.useMemo(function () {\n        var fragment = stableOptions.fragment, fragmentName = stableOptions.fragmentName, from = stableOptions.from, _a = stableOptions.optimistic, optimistic = _a === void 0 ? true : _a;\n        if (from === null) {\n            return {\n                result: diffToResult({\n                    result: {},\n                    complete: false,\n                }),\n            };\n        }\n        var cache = client.cache;\n        var diff = cache.diff(__assign(__assign({}, stableOptions), { returnPartialData: true, id: from, query: cache[\"getFragmentDoc\"](fragment, fragmentName), optimistic: optimistic }));\n        return {\n            result: diffToResult(__assign(__assign({}, diff), { result: client[\"queryManager\"].maskFragment({\n                    fragment: fragment,\n                    fragmentName: fragmentName,\n                    data: diff.result,\n                }) })),\n        };\n    }, [client, stableOptions]);\n    // Used for both getSnapshot and getServerSnapshot\n    var getSnapshot = React.useCallback(function () { return diff.result; }, [diff]);\n    return useSyncExternalStore(React.useCallback(function (forceUpdate) {\n        var lastTimeout = 0;\n        var subscription = stableOptions.from === null ?\n            null\n            : client.watchFragment(stableOptions).subscribe({\n                next: function (result) {\n                    // Since `next` is called async by zen-observable, we want to avoid\n                    // unnecessarily rerendering this hook for the initial result\n                    // emitted from watchFragment which should be equal to\n                    // `diff.result`.\n                    if (equal(result, diff.result))\n                        return;\n                    diff.result = result;\n                    // If we get another update before we've re-rendered, bail out of\n                    // the update and try again. This ensures that the relative timing\n                    // between useQuery and useFragment stays roughly the same as\n                    // fixed in https://github.com/apollographql/apollo-client/pull/11083\n                    clearTimeout(lastTimeout);\n                    lastTimeout = setTimeout(forceUpdate);\n                },\n            });\n        return function () {\n            subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();\n            clearTimeout(lastTimeout);\n        };\n    }, [client, stableOptions, diff]), getSnapshot, getSnapshot);\n}\nfunction diffToResult(diff) {\n    var result = {\n        data: diff.result,\n        complete: !!diff.complete,\n    };\n    if (diff.missing) {\n        result.missing = mergeDeepArray(diff.missing.map(function (error) { return error.missing; }));\n    }\n    return result;\n}\n//# sourceMappingURL=useFragment.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}